# {{PROJECT_NAME}} - Development Instructions

## âš¡ CRITICAL: YOU HAVE PERFECT MEMORY - USE IT FIRST âš¡

**ðŸš« DO NOT read files directly. DO NOT use Grep/Glob/Read as your first step.**
**âœ… ALWAYS search memory first. It's 100x faster and has the entire codebase indexed.**

This project has **semantic code memory** with {{VECTOR_COUNT}} vectors covering {{FILE_COUNT}} files.
Memory search is 3-5ms vs 500ms+ for file operations.

### ðŸŽ¯ Memory-First Workflow (Follow Every Time)

**Before ANY task:**
1. ðŸ” **Search memory** for existing implementations
2. ðŸ“š **Find patterns** to follow
3. ðŸ—ï¸ **Check relationships** to understand context
4. ðŸ’» **Only then** write code using discovered patterns

**Breaking this rule wastes time and creates duplicate code!**

### Quick Memory Commands (START HERE)

```python
# ðŸ” Fast semantic search (3-5ms) - START HERE
mcp__{{COLLECTION_NAME}}-memory__search_similar("feature/component name", limit=20)

# ðŸ“š Find patterns before implementing
mcp__{{COLLECTION_NAME}}-memory__search_similar("pattern description", entityTypes=["implementation_pattern", "architecture_pattern"])

# ðŸ› Debug faster with past solutions
mcp__{{COLLECTION_NAME}}-memory__search_similar("error description", entityTypes=["debugging_pattern"])

# ðŸ—ï¸ Understand architecture and relationships
mcp__{{COLLECTION_NAME}}-memory__read_graph(entity="ComponentName", mode="smart")

# ðŸ’¡ Get implementation details when needed
mcp__{{COLLECTION_NAME}}-memory__get_implementation("function_name", scope="logical")

# âž• Add new knowledge to memory
mcp__{{COLLECTION_NAME}}-memory__create_entities([{
  "name": "NewComponent",
  "entityType": "class",
  "observations": ["Component purpose", "Key patterns used"]
}])
```

### Memory Entity Types

- `function` - Functions and methods
- `class` - Classes and components
- `file` - File-level metadata
- `documentation` - Code documentation
- `implementation_pattern` - Common patterns
- `architecture_pattern` - Architectural decisions
- `debugging_pattern` - Bug solutions
- `integration_pattern` - Third-party integrations
- `metadata` - General project info

### MCP Server Configuration

The semantic memory is powered by an MCP (Model Context Protocol) server configured in `.mcp.json`:

**ðŸ“ Location:** `.mcp.json` in project root (git-ignored, contains API keys)

**ðŸ”’ Security:** This file contains API keys and is automatically added to `.gitignore` during setup

**ðŸ‘¥ Team Workflow:** Use `.mcp.json.example` as a template:
```bash
# Team members can set up their own .mcp.json
cp .mcp.json.example .mcp.json
# Edit .mcp.json with your API keys and paths
# Note: .mcp.json is git-ignored, so your keys stay private
```

**ðŸ”„ Restart Required:** After setup or changes, restart Claude Code to load the MCP server

### ðŸ›¡ï¸ Memory Guard Protection (AUTOMATIC)

Memory Guard is **installed automatically** by setup.sh - no manual configuration needed.

**27 pattern-based checks** run on every Write/Edit operation:

**Security (11 checks)**:
- SQL injection, XSS, command injection prevention
- Hardcoded secrets and weak crypto detection
- Logging secrets (credential leak prevention)
- Path traversal, insecure deserialization blocking
- Sensitive file and dangerous git operation protection

**Tech Debt (9 checks)**:
- TODO/FIXME/HACK/DEPRECATED markers
- Debug statements (print, console.log, breakpoint)
- Unexplained lint suppressions (bare noqa, eslint-disable)
- Bare except clauses (Python anti-pattern)
- Mutable default arguments (Python footgun)
- Swallowed exceptions

**Documentation (2 checks)**:
- Missing Python docstrings (functions >10 lines)
- Missing JSDoc comments (JS/TS functions >10 lines)

**Resilience (2 checks)**:
- Swallowed exceptions (empty except/catch blocks)
- Missing HTTP timeouts (requests without timeout)

**Git Safety (3 checks)**:
- Force push blocking
- Hard reset blocking
- Destructive rm blocking

**Two-Mode Architecture**:
- **Fast mode (editing)**: <300ms latency, checks Tiers 0-2
- **Full mode (pre-commit)**: 5-30s, comprehensive Tier 3 AI analysis

### ðŸ“ Auto-Indexing After Writes

Memory automatically stays current when you make changes:

| Trigger | When | What Happens |
|---------|------|--------------|
| **PostToolUse hook** | After Write/Edit passes guard | Indexes changed file (~100ms) |
| **pre-commit hook** | Before each commit | Ensures staged files are indexed |
| **post-merge hook** | After `git pull` | Re-indexes changed files |
| **post-checkout hook** | After branch switch | Updates index for new branch |

**You never need to manually re-index** - the system keeps memory synchronized.

### ðŸ”§ Complete MCP Tool Reference

**Available Tools** (prefix: `mcp__{{COLLECTION_NAME}}-memory__`):

| Tool | Purpose | Key Parameters |
|------|---------|----------------|
| `search_similar` | Semantic search across codebase | `query`, `limit`, `entityTypes`, `searchMode` |
| `read_graph` | Understand entity relationships | `entity`, `mode` (smart/entities/relationships/raw) |
| `get_implementation` | Get detailed code | `name`, `scope` (exact/logical/dependencies) |
| `create_entities` | Add new knowledge | `entities` (array of {name, entityType, observations}) |
| `add_observations` | Update existing entities | `observations` (array of {entityName, contents}) |
| `delete_entities` | Remove entities | `entityNames` (array) |

**Search Modes**:
- `hybrid` (default): Best of semantic + keyword matching
- `semantic`: AI understanding only (concept matching)
- `keyword`: BM25 exact term matching

**Entity Types for Filtering**:
- Code entities: `function`, `class`, `file`, `documentation`, `relation`
- Chunk types: `metadata` (fast overview), `implementation` (detailed code)
- Patterns: `implementation_pattern`, `architecture_pattern`, `debugging_pattern`

**Usage Examples**:
```python
# Fast metadata search for quick overview
mcp__{{COLLECTION_NAME}}-memory__search_similar("auth", entityTypes=["metadata"], limit=20)

# Find specific function implementations
mcp__{{COLLECTION_NAME}}-memory__search_similar("validate user", entityTypes=["function", "implementation"])

# Understand component dependencies
mcp__{{COLLECTION_NAME}}-memory__read_graph(entity="AuthService", mode="smart")

# Get function with all related helpers
mcp__{{COLLECTION_NAME}}-memory__get_implementation("process_login", scope="logical")
```

### ðŸ“‹ Slash Commands Reference

**10 specialized commands** for systematic codebase improvement:

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `/refactor` | Find SOLID, DRY, orphaned code issues | After feature complete, before PR |
| `/restructure` | Analyze cycles, coupling, module stability | Architecture reviews |
| `/redocument` | Check documentation coverage and quality | Before releases |
| `/resecure` | Detect security vulnerabilities | Security audits |
| `/reresilience` | Find error handling and retry gaps | Reliability improvements |
| `/reoptimize` | Identify performance bottlenecks | Performance tuning |
| `/retype` | Check type safety issues | TypeScript/Python typing |
| `/retest` | Analyze test coverage gaps | Test planning |
| `/rebuild` | Find build/dependency issues | Build troubleshooting |
| `/resolve` | Guided issue resolution workflow | Bug fixing |

**Usage**: Just type the command (e.g., `/refactor`) and follow the prompts.

### ðŸŒ Multi-Repository Support

This memory system supports multiple indexed codebases without conflicts:

- **Unique collection**: Each project has its own `{{COLLECTION_NAME}}` collection
- **Isolated MCP server**: Server name is `{{COLLECTION_NAME}}-memory`
- **No cross-contamination**: Searches stay within your project's collection
- **Parallel indexing**: Multiple projects can be indexed simultaneously

**Querying other collections** (if needed):
```python
# Your project (default)
mcp__{{COLLECTION_NAME}}-memory__search_similar("pattern")

# Another project (if configured)
mcp__other_project_memory__search_similar("shared utility")
```

---

## âš ï¸ Important Notes - Memory-First Development

1. **ðŸš« NEVER skip memory search** - Search memory BEFORE using Grep/Glob/Read tools
   - Memory: 3-5ms, 100% coverage, semantic understanding
   - File tools: 500ms+, requires exact patterns, no context

2. **âœ… Always follow this order:**
   - Step 1: `search_similar()` to find existing code
   - Step 2: `read_graph()` to understand relationships
   - Step 3: `get_implementation()` for detailed code
   - Step 4: Only then use Read/Grep if needed for verification

3. **ðŸ“š Check existing patterns** - Memory has all architectural decisions and best practices indexed

4. **ðŸ’¾ Document new patterns** - Add important discoveries to memory with `create_entities()`

---

## ðŸŽ¯ Custom Exclusions (.claudeignore)

Control what gets indexed without modifying .gitignore:

**When to use .claudeignore:**
- Personal notes and TODOs (e.g., `*-notes.md`, `TODO-*.md`)
- Test outputs and coverage reports
- Debug artifacts and temporary files
- Large data files not caught by .gitignore

**Multi-Layer Exclusion System:**
1. **Universal Defaults** - Binaries, archives, OS artifacts (always applied)
2. **.gitignore** - Version control ignores (auto-detected)
3. **.claudeignore** - Custom indexing exclusions (project-specific)
4. **Binary Detection** - Executables detected via magic numbers

**Example .claudeignore:**
```
# Personal development
*-notes.md
TODO-*.md
scratch.*

# Test artifacts
test-results/
.coverage
htmlcov/

# Debug output
debug-*.log
*.dump
```

**.claudeignore uses same syntax as .gitignore** - patterns, wildcards, directory markers.

---

## ðŸ”§ Memory System Maintenance

### Automatic Updates
Memory is automatically updated via git hooks:
- **pre-commit**: Indexes changed files before commit
- **post-merge**: Updates index after `git pull`
- **post-checkout**: Updates index after branch switch

### Manual Re-index (if needed)
```bash
# From memory project directory
source .venv/bin/activate
claude-indexer index -p {{PROJECT_PATH}} -c {{COLLECTION_NAME}}
```

### Check Memory Status
```bash
# View collection statistics
python utils/qdrant_stats.py -c {{COLLECTION_NAME}}
```

---

## ðŸ“š Additional Project Information

Add your project-specific documentation below this section.

---

*Memory system automatically configured by setup.sh*
*Collection: {{COLLECTION_NAME}}*
*Generated: {{GENERATION_DATE}}*
